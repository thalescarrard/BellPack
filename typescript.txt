// Import necessary hooks and components from React Native, Expo, and 3rd-party APIs
import React, { useState, useEffect, useRef } from 'react';
import { CameraView, Camera, useCameraPermissions } from 'expo-camera'; // For barcode scanning and image capture
import * as ImageManipulator from 'expo-image-manipulator'; // Resize images for better OCR
import * as MailComposer from 'expo-mail-composer'; // Compose and send emails
import { Alert, Text, View, StyleSheet, Button, Modal, TouchableOpacity, ActivityIndicator } from 'react-native';

// Endpoints for Firebase
const FIREBASE_PROXY_URL = "https://api-o6quombnba-uc.a.run.app";

// Define types for guest and package info
interface GuestInfo {
  name?: string;
  email?: string;
  room?: string | null;
  carrier?: string | null;
  date?: string | null;
  tracking?: string | null;
}
interface PackageInfo {
  carrier?: string | null;
  date?: string | null;
  tracking?: string | null;
  room?: string | null;
}

export default function App() {
  // React state variables
  const [guestInfo, setGuestInfo] = useState<GuestInfo | null>(null);
  const [hasPermission, setHasPermission] = useState<boolean | null>(null);
  const [isCameraActive, setIsCameraActive] = useState(false);
  const cameraRef = useRef<any | null>(null);
  const [loading, setLoading] = useState(false);
  const [showModal, setShowModal] = useState(false);
  const [scanned, setScanned] = useState(false);
  const [barcodeData, setBarcodeData] = useState<PackageInfo | null>(null);
  const [permission, requestPermission] = useCameraPermissions(); // ✅

useEffect(() => {
  if (!permission?.granted) {
    requestPermission();
  }
}, []);


  // Ask for camera permission on mount
  useEffect(() => {
    (async () => {
      try {
        const { status } = await Camera.requestCameraPermissionsAsync();
        setHasPermission(status === 'granted');
      } catch (error) {
        console.error("Camera permission error:", error);
        setHasPermission(false);
      }
    })();
  }, []);

  // When barcode is scanned, infer carrier and populate initial package info
  const onBarcodeScanned = ({ data }: { data: string }) => {
    if (scanned) return;
    setScanned(true);

    const inferredCarrier = data.startsWith('1Z') ? 'UPS' :
                            data.startsWith('9') ? 'USPS' :
                            data.startsWith('7') ? 'FedEx' :
                            data.startsWith('TBA') || data.startsWith('AMZ') || data.startsWith('AQ') ? 'Amazon' :
                            null;

    setBarcodeData({
      tracking: data,
      carrier: inferredCarrier,
      date: new Date().toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
      }),
    });

   // Alert.alert('Barcode Scanned', `Tracking: ${data}\nCarrier: ${inferredCarrier || 'Unknown'}`);
  };

// Sends an email notification to the guest about their package
const sendMail = async (guest: GuestInfo, info: PackageInfo = {} as PackageInfo) => {
  if (!guest.email) return;

  // Utility to safely clean text values
  const cleanText = (text: string | undefined | null) =>
    (text || '').replace(/\+/g, ' ').trim();

  const guestName = cleanText(guest.name);
  const subject = 'Package Received';

  // Email body content
  const body = `Hello ${guestName || 'Guest'},\n\nYour package has arrived at the front desk.\n\n` +
    `Date: ${info.date || guest.date || 'Unknown'}\n` +
    `Tracking Number: ${info.tracking || 'Unknown'}\n` +
    `Carrier: ${info.carrier || 'Unknown'}\n\n` +
    `Thank you.`;

  const options = {
    recipients: [guest.email],
    subject,
    body,
  };

  try {
    const result = await MailComposer.composeAsync(options);
    if (result.status === 'sent') {
      console.log('Email sent successfully');
    } else {
      console.log('Email not sent:', result.status);
    }
  } catch (error) {
    console.error('Failed to send email', error);
  }

  console.log('Email Date:', info.date);
};

// Queries guest info using the Google Script API
const fetchGuestInfo = async (query) => {
  try {
    const res = await fetch(`${FIREBASE_PROXY_URL}/proxy?q=${encodeURIComponent(query)}`);
    const json = await res.json();
    if (json.error) throw new Error(json.error);
    return json;
  } catch (e) {
    console.error('Failed to fetch guest info:', e);
    return null;
  }
};


// Extracts package info such as room number, date, carrier, and tracking number from raw OCR text
const extractPackageInfo = (text) => {
  const roomMatch = text.match(/Room[:\- ]?(\d+)/i);
  const dateMatch = text.match(/(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4})/);
  const carrierMatch = text.match(/UPS|FedEx|USPS|DHL/i);
  const trackingMatch = text.match(/[A-Z0-9]{10,}/);

  return {
    room: roomMatch ? roomMatch[1] : null,
    date: dateMatch ? dateMatch[1] : null,
    carrier: carrierMatch ? carrierMatch[0] : null,
    tracking: trackingMatch ? trackingMatch[0] : null,
  };
};

// Checks with the backend whether a given package is a duplicate (already logged)
const checkDuplicatePackage = async (guest: GuestInfo, tracking: string): Promise<boolean> => {
  try {
    const res = await fetch(`${FIREBASE_PROXY_URL}/proxy?checkDuplicate=1&email=${encodeURIComponent(guest.email)}&tracking=${encodeURIComponent(tracking)}`);
    const json = await res.json();
    return Boolean(json.isDuplicate);
  } catch (e) {
    console.error('Failed to check duplicate', e);
    return false;
  }
};

// Logs package information (name, email, room, carrier, tracking) to a Google Sheet via Apps Script
const logPackageInfo = async (guest: GuestInfo, info: PackageInfo) => {
  const logData = {
    name: guest.name,
    email: guest.email,
    room: guest.room || info.room, // Prefer guest's room, fallback to info
    carrier: info.carrier,
    tracking: info.tracking,
  };

  try {
    // Send the log data to the server (Google Apps Script)
    const res = await fetch(`${FIREBASE_PROXY_URL}/proxy`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(logData),
    });

    // Output the server's response (for debugging/logging)
    const text = await res.text();
    console.log('Logging response:', text);
  } catch (e) {
    // Catch and log any network or server errors
    console.error('Failed to log package info', e);
  }
};

// Captures a photo from the camera, runs OCR, extracts guest/package info, and shows a modal if successful
const handleTakePicture = async () => {
  if (!cameraRef) return;

  const currentScanDate = new Date().toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  });

  setLoading(true);

  try {
    let photo = await cameraRef.current.takePictureAsync({ base64: true });

    const manipResult = await ImageManipulator.manipulateAsync(
      photo.uri,
      [{ resize: { width: 1200 } }],
      { base64: true }
    );

    // Send image to backend for OCR
    const response = await fetch(`${FIREBASE_PROXY_URL}/ocr-proxy`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        imageBase64: manipResult.base64,
      }),
    });

    const result = await response.json();

     // 🔍 Adjusted to handle nested OCR response shape
    const text = result?.text || result?.ParsedResults?.[0]?.ParsedText?.trim();

    if (!text) {
      Alert.alert('OCR Error', result.error || 'Unable to read label text.');
      console.log('OCR Text:', text);
      setLoading(false);
      setIsCameraActive(false);
      return;
    }

    console.log('OCR Text:', text);

    const lines = text.split('\n').map(line => line.trim()).filter(line => line);

    let query: string | null = null;

    const emailMatch = text.match(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-z]{2,}/);
    if (emailMatch) {
      query = emailMatch[0];
    } else {
      const nameMatch = text.match(/Name[:\- ]+([A-Za-z ]+)/i);
      if (nameMatch) {
        query = nameMatch[1].trim();
      } else {
        const nameCandidate = lines.find(line =>
          /^[A-Za-z\s]{5,30}$/.test(line)
        );
        if (nameCandidate) query = nameCandidate;
      }
    }

    if (!query) {
      Alert.alert('No Guest Info Found', 'Could not extract a name or email from the label.');
      setLoading(false);
      setIsCameraActive(false);
      return;
    }

    const extracted = extractPackageInfo(text);

    const combinedInfo = {
      ...extracted,
      ...barcodeData,
      tracking: barcodeData?.tracking || extracted.tracking,
      carrier: barcodeData?.carrier || extracted.carrier,
    };

    const guest = await fetchGuestInfo(query);

    if (guest) {
      const fullGuestInfo = {
        ...guest,
        ...combinedInfo,
        room: guest.room || combinedInfo.room,
        date: currentScanDate,
      };

      // === Check for duplicate ===
      if (combinedInfo.tracking) {
        const isDuplicate = await checkDuplicatePackage(fullGuestInfo, combinedInfo.tracking);
        if (isDuplicate) {
          Alert.alert(
            'Duplicate Package',
            `This package (tracking: ${combinedInfo.tracking}) has already been logged for:\n\n` +
              `Name: ${guest.name}\nEmail: ${guest.email}\nRoom: ${guest.room || 'N/A'}`,
            [
              { text: 'Cancel', style: 'cancel' },
              { text: 'Email Guest', onPress: () => sendMail(fullGuestInfo, combinedInfo) },
            ]
          );
          setGuestInfo(fullGuestInfo);
          setLoading(false);
          return;
        }
      }

      setGuestInfo(fullGuestInfo);
      setShowModal(true);
    } else {
      setGuestInfo(null);
    }

    setIsCameraActive(false);
    setLoading(false);
  } catch (error) {
    console.error(error);
    setLoading(false);
    setIsCameraActive(false);
  }
};

// Handle camera permission statuses
if (hasPermission === null) return <Text>Requesting camera permission...</Text>; // Still waiting for user response
if (hasPermission === false) return <Text>No access to camera.</Text>; // User denied camera access

return (
  <View style={styles.container}>
    <Text style={styles.title}>Package Label OCR</Text>

    {/* Show this block when the camera is not active */}
    {!isCameraActive && (
      <>
        {/* Button to activate the camera and start scanning */}
        <Button title="Scan Label" onPress={() => {
          setScanned(false);
          setBarcodeData(null);
          setIsCameraActive(true);
        }} />
        <View style={{ marginTop: 10 }} />

        {/* Show extracted guest information if available */}
        {guestInfo?.name && (
          <View style={styles.guestInfo}>
            <Text>Name: {guestInfo.name}</Text>
            <Text>Email: {guestInfo.email}</Text>
            {guestInfo.room && <Text>Room: {guestInfo.room}</Text>}
          </View>
        )}
      </>
    )}

    {/* Camera view and capture controls when camera is active */}
    {isCameraActive && (
      <>
        <CameraView
          ref={cameraRef}
          style={styles.camera}
          onBarcodeScanned={onBarcodeScanned}
          barcodeScannerSettings={{
            barcodeTypes: ['code128', 'code39', 'code93', 'upc_a', 'ean13', 'qr'] // Supported barcode formats
          }}
        />
        {/* Buttons to take picture or cancel scanning */}
        <Button title="Capture Label" onPress={handleTakePicture} />
        <Button title="Cancel" onPress={() => setIsCameraActive(false)} />
      </>
    )}

  {/* Show a loading spinner while processing */}
  {loading && <ActivityIndicator size="large" style={{ marginTop: 20 }} />}

  {/* Modal for confirming whether to notify the guest */}
  <Modal visible={showModal} transparent animationType="slide">
    <View style={styles.modalOverlay}>
      <View style={styles.modalContent}>
        <Text style={{ fontWeight: 'bold', fontSize: 18 }}>Notify Guest?</Text>

        {/* Display guest info inside the modal, if available */}
        {guestInfo && (
          <>
            <Text>Name: {guestInfo.name}</Text>
            <Text>Email: {guestInfo.email}</Text>
            <Text>Room: {guestInfo.room || 'N/A'}</Text>
          </>
        )}

        {/* Modal action buttons */}
        <View style={{ flexDirection: 'row', marginTop: 20 }}>
          {/* Cancel button simply closes the modal */}
          <TouchableOpacity
            style={[styles.button, { backgroundColor: 'gray' }]}
            onPress={() => setShowModal(false)}
          >
            <Text style={styles.buttonText}>Cancel</Text>
          </TouchableOpacity>

          {/* Confirm button triggers guest notification logic */}
          <TouchableOpacity
            style={[styles.button, { backgroundColor: 'green' }]}
            onPress={async () => {
              // Ensure a tracking number exists before continuing
              if (!guestInfo.tracking) {
                Alert.alert('Error', 'No tracking number found for this package.');
                return;
              }

              // Check for duplicates again before final logging and emailing
              const isDuplicate = await checkDuplicatePackage(guestInfo, guestInfo.tracking);

              if (isDuplicate) {
                Alert.alert(
                  'Duplicate Package',
                  `This package (tracking: ${guestInfo.tracking}) has already been logged for:\n\n` +
                    `Name: ${guestInfo.name}\nEmail: ${guestInfo.email}\nRoom: ${guestInfo.room || 'N/A'}`,
                  [
                    { text: 'Cancel', style: 'cancel' },
                    { text: 'Email Guest', onPress: () => sendMail(guestInfo, guestInfo) },
                  ]
                );
                setShowModal(false);
                return;
              }

              // Log package info and send guest notification email
              await logPackageInfo(guestInfo, guestInfo);
              await sendMail(guestInfo, {
                carrier: guestInfo.carrier,
                tracking: guestInfo.tracking,
                date: guestInfo.date || new Date().toLocaleDateString('en-US', {
                  year: 'numeric',
                  month: 'long',
                  day: 'numeric',
                }),
                room: guestInfo.room,
              });

              // Close the modal after actions are complete
              setShowModal(false);
            }}
          >
            <Text style={styles.buttonText}>Yes</Text>
          </TouchableOpacity>
        </View>
      </View>
    </View>
  </Modal>
  </View>
  );
}

const styles = StyleSheet.create({
  // Main container layout for the screen
  container: {
    flex: 1,
    paddingTop: 50,
    alignItems: 'center',
    backgroundColor: '#fff', // white background for a clean look
  },

  // Title text at the top of the screen
  title: {
    fontSize: 24,
    marginBottom: 20, // spacing below title
  },

  // Style for the camera preview window
  camera: {
    width: '90%',
    height: 300,
    marginBottom: 10, // space below the camera view
  },

  // Box to display guest information (e.g. name, email)
  guestInfo: {
    marginTop: 20,
    padding: 10,
    borderWidth: 1,
    borderColor: '#ccc', // light gray border
    width: '90%',
  },

  // Semi-transparent background overlay for the modal
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)', // dark overlay
    justifyContent: 'center',
    alignItems: 'center', // center modal content
  },

  // White popup modal box with padding and rounded corners
  modalContent: {
    backgroundColor: '#fff',
    padding: 20,
    borderRadius: 10,
    width: '80%',
    alignItems: 'center',
  },

  // Generic button styling used in the modal
  button: {
    padding: 10,
    borderRadius: 5,
    marginHorizontal: 10, // space between buttons
  },

  // Text inside buttons — white and bold
  buttonText: {
    color: '#fff',
    fontWeight: 'bold',
  },
});

